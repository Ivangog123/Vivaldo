<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Inteligente de Pré-Diagnóstico</title>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Custom Font: Inter for professional look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }

        #root {
            height: 100%;
            overflow-y: auto;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* Custom Scrollbar */
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .typing-dot {
            animation: typing 1.4s infinite ease-in-out both;
        }
        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes typing {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Mapa */
        #map {
            width: 100%;
            height: 320px;
            border-radius: 12px;
            display: none; /* Esconde o mapa inicialmente */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- DATASET LOCAL ---
        const DATASET_SINTOMAS = {
            "cabeça": "Cefaleia, enxaqueca ou tensão.",
            "febre": "Infecção viral ou bacteriana.",
            "tosse": "Alergia, gripe ou bronquite.",
            "peito": "ALERTA: Dor no peito requer urgência médica imediata.",
            "ar": "ALERTA: Falta de ar é emergência.",
            "barriga": "Gases, gastrite ou cólica.",
            "garganta": "Inflamação, faringite ou amigdalite.",
            "pele": "Dermatite, alergia ou infecção cutânea.",
            "costas": "Tensão muscular, má postura ou problema renal."
        };

        // --- ÍCONES ---
        const SendIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
        );
        
        const StethoscopeIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4.8 2.3A.3.3 0 1 0 5 2H4a2 2 0 0 0-2 2v5a6 6 0 0 0 6 6v0a6 6 0 0 0 6-6V4a2 2 0 0 0-2-2h-1a.2.2 0 1 0 .3.3"></path><path d="M8 15v1a6 6 0 0 0 6 6v0a6 6 0 0 0-6-6v-4"></path><circle cx="20" cy="10" r="2"></circle></svg>
        );

        const AlertIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ca8a04" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
        );

        // --- PARSER DE TEXTO SIMPLES (MARKDOWN) ---
        const FormattedText = ({ text }) => {
            // Divide o texto por quebras de linha
            const lines = text.split('\n');
            
            return (
                <div className="space-y-1 text-sm leading-relaxed text-gray-700">
                    {lines.map((line, i) => {
                        if (!line.trim()) return <br key={i} />;
                        
                        // Renderiza negrito
                        const parts = line.split(/(\*\*.*?\*\*)/g);
                        return (
                            <p key={i}>
                                {parts.map((part, j) => {
                                    if (part.startsWith('**') && part.endsWith('**')) {
                                        return <strong key={j} className="text-teal-900 font-bold">{part.slice(2, -2)}</strong>;
                                    }
                                    return part;
                                })}
                            </p>
                        );
                    })}
                </div>
            );
        };

        // --- COMPONENTE PRINCIPAL ---
        const App = () => {
            const [messages, setMessages] = useState([
                { 
                    id: 1, 
                    sender: 'ai', 
                    text: "Olá. Sou o seu assistente virtual de pré-diagnóstico. Descreva os seus sintomas para que eu possa ajudar.",
                    localAlert: null 
                }
            ]);
            const [inputValue, setInputValue] = useState("");
            const [isLoading, setIsLoading] = useState(false);
            const chatEndRef = useRef(null);
            const textareaRef = useRef(null);
            const [userLocation, setUserLocation] = useState(null);
            const [places, setPlaces] = useState([]);
            const mapRefLeaflet = useRef(null);
            const [placesLoading, setPlacesLoading] = useState(false);
            const [locationAsked, setLocationAsked] = useState(false); // Controla se já pediu localização

            // Chave API (No vosso projeto final, a chave não pode ficar exposta no frontend, deve ser usada via backend)
            const apiKey = "AIzaSyA3e50lF_UPCYHXtvYPg9gDEuSNqp9FZUo";

            // Scroll automático para a última mensagem
            useEffect(() => {
                chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [messages, isLoading]);

            // Ajuste automático da altura do textarea
            const handleInput = (e) => {
                setInputValue(e.target.value);
                e.target.style.height = 'auto';
                e.target.style.height = `${Math.min(e.target.scrollHeight, 120)}px`;
            };

            const checkLocalDataset = (text) => {
                const lowerText = text.toLowerCase();
                let detected = null;
                
                for (const [key, value] of Object.entries(DATASET_SINTOMAS)) {
                    if (lowerText.includes(key)) {
                        detected = { keyword: key, desc: value };
                        break; // Pega a primeira ocorrência relevante
                    }
                }
                return detected;
            };

            // Cálculo de distância Haversine em km
            const haversineKm = (lat1, lon1, lat2, lon2) => {
                const toRad = (v) => v * Math.PI / 180;
                const R = 6371;
                const dLat = toRad(lat2 - lat1);
                const dLon = toRad(lon2 - lon1);
                const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            };

            // Pede localização ao browser
            const getUserLocation = () => new Promise((resolve, reject) => {
                if (!navigator.geolocation) return reject(new Error('Geolocation não suportada'));
                if (locationAsked) return reject(new Error('Localização já foi pedida anteriormente'));
                
                setLocationAsked(true);
                navigator.geolocation.getCurrentPosition(
                    (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
                    (err) => reject(err),
                    { enableHighAccuracy: true, timeout: 15000 }
                );
            });

            // Inicializa o mapa Leaflet (se ainda não inicializado) e MOSTRA o mapa
            const initMap = (lat, lon) => {
                // Mostra o mapa
                const mapElement = document.getElementById('map');
                if (mapElement) {
                    mapElement.style.display = 'block';
                }

                // Se já existe, apenas ajustar vista e garantir render
                if (mapRefLeaflet.current) {
                    try { 
                        mapRefLeaflet.current.setView([lat, lon], 13); 
                        setTimeout(()=>{ try { mapRefLeaflet.current.invalidateSize(); } catch(e){} }, 200);
                    } catch(e){/*silent*/} 
                    return;
                }
                const map = L.map('map', { preferCanvas: true }).setView([lat, lon], 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; OpenStreetMap'
                }).addTo(map);
                L.marker([lat, lon]).addTo(map).bindPopup('A sua localização').openPopup();
                mapRefLeaflet.current = map;
                // garantir que o mapa fica visível após render do container
                setTimeout(()=>{ try { map.invalidateSize(); } catch(e){} }, 250);
            };

            // Consulta Overpass API para amenity=hospital|clinic|pharmacy num raio (metros)
            const fetchNearbyPlaces = async (lat, lon, radius = 5000) => {
                setPlacesLoading(true);
                try {
                    const query = `
                        [out:json][timeout:25];
                        (
                          node["amenity"~"hospital|pharmacy|clinic"](around:${radius},${lat},${lon});
                          way["amenity"~"hospital|pharmacy|clinic"](around:${radius},${lat},${lon});
                          relation["amenity"~"hospital|pharmacy|clinic"](around:${radius},${lat},${lon});
                        );
                        out center;
                    `;
                    const resp = await fetch('https://overpass-api.de/api/interpreter', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' },
                        body: query
                    });
                    const data = await resp.json();
                    const results = (data.elements || []).map(el => {
                        const latEl = el.lat ?? (el.center && el.center.lat);
                        const lonEl = el.lon ?? (el.center && el.center.lon);
                        return {
                            id: el.id,
                            name: (el.tags && (el.tags.name || el.tags['addr:street'])) || 'Sem nome',
                            amenity: el.tags && el.tags.amenity ? el.tags.amenity : 'local',
                            lat: latEl,
                            lon: lonEl,
                            distanceKm: latEl ? haversineKm(lat, lon, latEl, lonEl) : Infinity,
                            tags: el.tags || {}
                        };
                    }).filter(r => r.lat && r.lon)
                      .sort((a,b) => a.distanceKm - b.distanceKm)
                      .slice(0, 20); // limitar para performance

                    setPlaces(results);

                    // Adicionar marcadores ao mapa
                    if (!mapRefLeaflet.current) initMap(lat, lon);
                    if (mapRefLeaflet.current._placesLayer) {
                        mapRefLeaflet.current.removeLayer(mapRefLeaflet.current._placesLayer);
                    }
                    const markers = L.layerGroup();
                    results.forEach(p => {
                        const color = p.amenity === 'hospital' ? '#e11d48' : (p.amenity === 'pharmacy' ? '#059669' : '#0ea5e9');
                        const marker = L.circleMarker([p.lat, p.lon], {
                            radius: 8,
                            fillColor: color,
                            color: '#fff',
                            weight: 1,
                            fillOpacity: 0.9
                        });
                        const popupHtml = `<strong>${p.name}</strong><br/><em>${p.amenity}</em><br/>${p.distanceKm.toFixed(2)} km
                            <br/><a target="_blank" href="https://www.openstreetmap.org/?mlat=${p.lat}&mlon=${p.lon}#map=18/${p.lat}/${p.lon}">Abrir no OSM</a>`;
                        marker.bindPopup(popupHtml);
                        marker.addTo(markers);
                    });
                    markers.addTo(mapRefLeaflet.current);
                    mapRefLeaflet.current._placesLayer = markers;
                    // assegura render correcto do mapa
                    setTimeout(()=>{ try { mapRefLeaflet.current.invalidateSize(); } catch(e){} }, 200);

                    return results;
                } catch (err) {
                    console.error('Overpass error', err);
                    return [];
                } finally {
                    setPlacesLoading(false);
                }
            };

            // PEDIR GEOLOCALIZAÇÃO ao abrir a página
            useEffect(() => {
                // tentar obter localização; se falhar, inicializar mapa com vista padrão
                getUserLocation()
                    .then(coords => {
                        setUserLocation(coords);
                        // NOTA: initMap só será chamado quando necessário, não aqui
                    })
                    .catch(err => {
                        console.warn('Geolocalização indisponível/no permission on load', err);
                        // Não inicializa o mapa aqui - só quando necessário
                    });
            }, []);

            const handleSend = async () => {
                if (!inputValue.trim()) return;

                const userText = inputValue;
                setInputValue("");
                if (textareaRef.current) textareaRef.current.style.height = 'auto';

                // 1. Verificar Dataset Local
                const localMatch = checkLocalDataset(userText);

                // 2. Adicionar mensagem do usuário à UI
                const newUserMsg = { 
                    id: Date.now(), 
                    sender: 'user', 
                    text: userText,
                    localAlert: null 
                };
                setMessages(prev => [...prev, newUserMsg]);
                setIsLoading(true);

                try {
                    // 3. Construir Prompt
                    let promptContext = "";
                    if (localMatch) {
                        promptContext = `[SISTEMA INTERNO: Identificou palavra-chave '${localMatch.keyword}' associada a '${localMatch.desc}'. Considere isto.] `;
                    }

                    const systemInstruction = `
                    Você é um assistente médico especializado em pré-diagnóstico para seguradoras.
                    OBJETIVO: Fornecer um pré-diagnóstico preliminar, indicar urgência e encaminhamento.
                    INSTRUÇÕES DETALHADAS:
                    - Analise a descrição do utilizador: "${userText}". ${promptContext}
                    - Se a entrada NÃO descrever sintomas (por ex.: perguntas administrativas, nomes próprios, agradecimentos, pedidos de informação geral), responda pedindo clarificação usando uma pergunta específica (ex: "Poderia descrever os sintomas, duração e intensidade?").
                    - Identifique sinais de emergência (dor torácica súbita, falta de ar intensa, perda de consciência, hemorragia profusa). Se suspeitar de emergência, escreva "URGENCIA" e recomende contato imediato com 112.
                    - Liste possíveis causas (curtas), classifique a urgência (NORMAL / MODERADA / URGÊNCIA) e indique o especialista mais apropriado.
                    - Sugira exames complementares apenas se relevantes.
                    - Use linguagem clara em Português de Portugal, seja conciso e objetivo.
                    - Se for possível, inclua perguntas de seguimento quando a informação for insuficiente.
                    - Evite termos técnicos complexos; prefira explicações simples.
                    - Os nomes de doenças devem ser apresentados também em markdown negritados.
                    
                    FORMATO DE RESPOSTA OBRIGATÓRIO (Use Markdown):
                    > [Breve explicação clínica]
                    
                    **Possível Diagnóstico:** [Lista]
                    **Urgência:** [Nível]
                    **Especialista Indicado:** [Nome]
                    **Recomendações:** [Lista breve]
                    `;

                    // 4. Chamada à API Gemini
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: systemInstruction }] }]
                        })
                    });

                    const data = await response.json();
                    
                    let aiText = "Desculpe, não consegui processar o pedido. Tente novamente.";
                    if (data.candidates && data.candidates[0]?.content?.parts[0]?.text) {
                        aiText = data.candidates[0].content.parts[0].text;
                    } else if (data.error) {
                        aiText = "Erro de conexão com o serviço de IA. Verifique a chave API.";
                    }

                    // 5. Adicionar resposta da IA à Interface Gráfica
                    const newAiMsg = {
                        id: Date.now() + 1,
                        sender: 'ai',
                        text: aiText,
                        localAlert: localMatch
                    };

                    setMessages(prev => [...prev, newAiMsg]);

                    // --- OBTER LOCALIZAÇÃO E MOSTRAR MAPA/LOCAIS ---
                    try {
                        let coords;
                        if (userLocation) {
                            coords = userLocation;
                        } else {
                            coords = await getUserLocation();
                            setUserLocation(coords);
                        }
                        
                        initMap(coords.lat, coords.lon);
                        // buscar locais próximos (hospital/clínica/farmácia) e receber resultados
                        const found = await fetchNearbyPlaces(coords.lat, coords.lon, 5000);

                        // Fazer com que o assistente "diga" os locais encontrados (as primeiras entradas)
                        if (found && found.length > 0) {
                            const top = found.slice(0, 6);
                            const listText = top.map((p, i) => `${i+1}. ${p.name} — ${p.amenity} — ${p.distanceKm.toFixed(2)} km`).join('\n');
                            const aiPlacesText = `Encontrei os seguintes locais próximos que podem ajudar:\n\n${listText}\n\nNo mapa abaixo pode tocar em cada marcador para mais detalhes.`;
                            setMessages(prev => [...prev, { id: Date.now() + 3, sender: 'ai', text: aiPlacesText, localAlert: null }]);
                        } else {
                            setMessages(prev => [...prev, { id: Date.now() + 4, sender: 'ai', text: 'Não foram encontrados hospitais, centros ou farmácias nas proximidades dentro do raio selecionado.', localAlert: null }]);
                        }

                    } catch (geoErr) {
                        console.warn('Geolocalização não disponível ou negada', geoErr);
                        setMessages(prev => [...prev, {
                            id: Date.now() + 2,
                            sender: 'ai',
                            text: 'Para mostrar locais próximos (hospitais/centros/farmácias) precisa de permitir a geolocalização no seu navegador. Pode permitir nas definições do site.',
                            localAlert: null
                        }]);
                    }

                } catch (error) {
                    console.error(error);
                    setMessages(prev => [...prev, { 
                        id: Date.now() + 1, 
                        sender: 'ai', 
                        text: "Ocorreu um erro técnico. Por favor, tente mais tarde.",
                        localAlert: null
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };

            return (
                <div className="flex flex-col min-h-screen bg-gray-100">
                    
                    {/* HEADER */}
                    <header className="bg-teal-700 text-white p-4 shadow-lg z-10 flex items-center justify-between shrink-0">
                        <div className="flex items-center gap-3">
                            <div className="bg-white/10 p-2 rounded-full">
                                <StethoscopeIcon />
                            </div>
                            <div>
                                <h1 className="font-bold text-lg leading-tight">Sistema Inteligente</h1>
                                <p className="text-teal-200 text-xs font-medium tracking-wide">Pré-Diagnóstico & Encaminhamento</p>
                            </div>
                        </div>
                    </header>

                    {/* ÁREA DE CHAT */}
                    <main className="flex-1 p-4 space-y-6 w-full max-w-4xl mx-auto">
                        {messages.map((msg) => (
                            <div key={msg.id} className={`flex flex-col ${msg.sender === 'user' ? 'items-end' : 'items-start'}`}>
                                
                                {/* ALERTA DO SISTEMA LOCAL (Aparece associado à resposta da IA) */}
                                {msg.sender === 'ai' && msg.localAlert && (
                                    <div className="mb-2 bg-yellow-50 border border-yellow-200 text-yellow-800 text-xs px-3 py-2 rounded-lg flex items-center gap-2 shadow-sm max-w-[85%] md:max-w-[70%] animate-fade-in">
                                        <AlertIcon />
                                        <span>
                                            <strong>Sistema Local identificou:</strong> {msg.localAlert.keyword.toUpperCase()} - {msg.localAlert.desc}
                                        </span>
                                    </div>
                                )}

                                {/* BOLHA DE MENSAGEM */}
                                <div className={`
                                    relative px-5 py-3 rounded-2xl text-base shadow-sm max-w-[85%] md:max-w-[70%]
                                    ${msg.sender === 'user' 
                                        ? 'bg-teal-600 text-white rounded-br-none' 
                                        : 'bg-white text-gray-800 rounded-bl-none border border-gray-100'}
                                `}>
                                    {msg.sender === 'ai' ? (
                                        <FormattedText text={msg.text} />
                                    ) : (
                                        <p>{msg.text}</p>
                                    )}
                                </div>
                                
                                <span className="text-[10px] text-gray-400 mt-1 px-1">
                                    {msg.sender === 'user' ? 'Você' : 'Assistente Médico'}
                                </span>
                            </div>
                        ))}

                        {/* INDICADOR DE LOADING */}
                        {isLoading && (
                            <div className="flex items-start">
                                <div className="bg-white px-4 py-3 rounded-2xl rounded-bl-none border border-gray-100 shadow-sm flex items-center gap-1">
                                    <div className="w-2 h-2 bg-teal-500 rounded-full typing-dot"></div>
                                    <div className="w-2 h-2 bg-teal-500 rounded-full typing-dot"></div>
                                    <div className="w-2 h-2 bg-teal-500 rounded-full typing-dot"></div>
                                </div>
                            </div>
                        )}
                        
                        {/* --- MAPA E LISTA DE LOCAIS PRÓXIMOS (aparece após resposta) --- */}
                        {(userLocation || places.length > 0) && (
                            <div className="max-w-4xl mx-auto space-y-2">
                                <h3 className="text-sm font-semibold text-gray-700">Mapa — locais próximos (hospitais, centros, farmácias)</h3>
                                <div id="map" className="shadow-sm rounded-lg overflow-hidden"></div>

                                <div className="bg-white p-3 rounded-lg border border-gray-100">
                                    <div className="flex items-center justify-between mb-2">
                                        <span className="text-xs text-gray-500">Resultados próximos</span>
                                        {placesLoading ? <span className="text-[11px] text-gray-400">A procurar...</span> : <span className="text-[11px] text-gray-400">{places.length} locais</span>}
                                    </div>
                                    <ul className="space-y-2 text-sm text-gray-700 max-h-48 overflow-auto">
                                        {places.map(p => (
                                            <li key={p.id} className="flex items-start justify-between">
                                                <div>
                                                    <div className="font-medium">{p.name}</div>
                                                    <div className="text-xs text-gray-500">{p.amenity} • {p.distanceKm.toFixed(2)} km</div>
                                                </div>
                                                <div className="text-right">
                                                    <button onClick={() => {
                                                        if (mapRefLeaflet.current) {
                                                            mapRefLeaflet.current.setView([p.lat, p.lon], 17);
                                                            // abrir popup: procurar camada e abrir popup aproximado
                                                        }
                                                    }} className="text-xs text-teal-600 hover:underline">centra no mapa</button>
                                                </div>
                                            </li>
                                        ))}
                                        {places.length === 0 && !placesLoading && <li className="text-xs text-gray-400">Nenhum local encontrado no raio selecionado.</li>}
                                    </ul>
                                </div>
                            </div>
                        )}

                        <div ref={chatEndRef} />
                    </main>

                    {/* ÁREA DE INPUT */}
                    <footer className="bg-white p-4 border-t border-gray-200 shrink-0">
                        <div className="max-w-4xl mx-auto relative flex items-end gap-2 bg-gray-50 border border-gray-300 rounded-xl p-2 focus-within:ring-2 focus-within:ring-teal-500 focus-within:border-teal-500 transition-all">
                            <textarea
                                ref={textareaRef}
                                value={inputValue}
                                onChange={handleInput}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter' && !e.shiftKey) {
                                        e.preventDefault();
                                        handleSend();
                                    }
                                }}
                                placeholder="Descreva os seus sintomas..."
                                className="w-full bg-transparent border-none focus:ring-0 resize-none text-gray-700 max-h-32 py-2 px-2 scrollbar-hide"
                                rows={1}
                            ></textarea>
                            <button 
                                onClick={handleSend}
                                disabled={isLoading || !inputValue.trim()}
                                className={`p-2 rounded-lg transition-colors mb-0.5
                                    ${isLoading || !inputValue.trim() 
                                        ? 'bg-gray-200 text-gray-400 cursor-not-allowed' 
                                        : 'bg-teal-600 text-white hover:bg-teal-700 shadow-md'}
                                `}
                            >
                                <SendIcon />
                            </button>
                        </div>
                        <div className="text-center mt-2">
                             <p className="text-[10px] text-gray-400">Este sistema é uma IA de apoio e não substitui uma consulta médica real. Em emergências, ligue 112.</p>
                        </div>
                    </footer>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>